//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.7.6, generator: @autorest/go@4.0.0-preview.42)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package generated

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// MarshalJSON implements the json.Marshaller interface for type AdhocBasedTriggerContext.
func (a AdhocBasedTriggerContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = "AdhocBasedTriggerContext"
	populate(objectMap, "taggingCriteria", a.TaggingCriteria)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdhocBasedTriggerContext.
func (a *AdhocBasedTriggerContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		case "taggingCriteria":
				err = unpopulate(val, "TaggingCriteria", &a.TaggingCriteria)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBackupParams.
func (a AzureBackupParams) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupType", a.BackupType)
	objectMap["objectType"] = "AzureBackupParams"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBackupParams.
func (a *AzureBackupParams) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupType":
				err = unpopulate(val, "BackupType", &a.BackupType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBackupParamsForPlugin.
func (a AzureBackupParamsForPlugin) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoHealSettings", a.AutoHealSettings)
	populate(objectMap, "backupType", a.BackupType)
	objectMap["objectType"] = "AzureBackupParamsForPlugin"
	populate(objectMap, "policyInfo", a.PolicyInfo)
	populate(objectMap, "policyParameters", a.PolicyParameters)
	populate(objectMap, "retentionTag", a.RetentionTag)
	populate(objectMap, "triggerType", a.TriggerType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBackupParamsForPlugin.
func (a *AzureBackupParamsForPlugin) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoHealSettings":
				err = unpopulate(val, "AutoHealSettings", &a.AutoHealSettings)
				delete(rawMsg, key)
		case "backupType":
				err = unpopulate(val, "BackupType", &a.BackupType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		case "policyInfo":
				err = unpopulate(val, "PolicyInfo", &a.PolicyInfo)
				delete(rawMsg, key)
		case "policyParameters":
				err = unpopulate(val, "PolicyParameters", &a.PolicyParameters)
				delete(rawMsg, key)
		case "retentionTag":
				err = unpopulate(val, "RetentionTag", &a.RetentionTag)
				delete(rawMsg, key)
		case "triggerType":
				err = unpopulate(val, "TriggerType", &a.TriggerType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureOperationalStoreParameters.
func (a AzureOperationalStoreParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataStoreType", a.DataStoreType)
	objectMap["objectType"] = "AzureOperationalStoreParameters"
	populate(objectMap, "resourceGroupId", a.ResourceGroupID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureOperationalStoreParameters.
func (a *AzureOperationalStoreParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataStoreType":
				err = unpopulate(val, "DataStoreType", &a.DataStoreType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &a.ObjectType)
				delete(rawMsg, key)
		case "resourceGroupId":
				err = unpopulate(val, "ResourceGroupID", &a.ResourceGroupID)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupRequest.
func (b BackupRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "backupParameters", b.BackupParameters)
	populate(objectMap, "datasource", b.Datasource)
	populate(objectMap, "datasourceAccessToken", b.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", b.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", b.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", b.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", b.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", b.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BackupRequestBase.
func (b BackupRequestBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "backupParameters", b.BackupParameters)
	populate(objectMap, "datasource", b.Datasource)
	populate(objectMap, "datasourceAccessToken", b.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", b.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", b.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", b.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", b.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BackupRule.
func (b BackupRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoHealSettings", b.AutoHealSettings)
	populate(objectMap, "backupParameters", b.BackupParameters)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "objectType", b.ObjectType)
	populate(objectMap, "targetDatastore", b.TargetDatastore)
	populate(objectMap, "trigger", b.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupRule.
func (b *BackupRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoHealSettings":
				err = unpopulate(val, "AutoHealSettings", &b.AutoHealSettings)
				delete(rawMsg, key)
		case "backupParameters":
				b.BackupParameters, err = unmarshalBackupParametersClassification(val)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &b.Name)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		case "targetDatastore":
				err = unpopulate(val, "TargetDatastore", &b.TargetDatastore)
				delete(rawMsg, key)
		case "trigger":
				b.Trigger, err = unmarshalTriggerContextClassification(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BackupSchedule.
func (b BackupSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "repeatingTimeIntervals", b.RepeatingTimeIntervals)
	populate(objectMap, "timeZone", b.TimeZone)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BackupSettings.
func (b BackupSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataSourceType", b.DataSourceType)
	populate(objectMap, "objectType", b.ObjectType)
	populate(objectMap, "policyName", b.PolicyName)
	populate(objectMap, "policyParameters", b.PolicyParameters)
	populate(objectMap, "rawJsonSetting", b.RawJSONSetting)
	populate(objectMap, "rules", b.Rules)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BaseRequest.
func (b BaseRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", b.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", b.DatasourceAccessToken)
	populate(objectMap, "jobLibraryInitializationParams", b.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type BlobBackupDatasourceParameters.
func (b BlobBackupDatasourceParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containersList", b.ContainersList)
	objectMap["objectType"] = "BlobBackupDatasourceParameters"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobBackupDatasourceParameters.
func (b *BlobBackupDatasourceParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containersList":
				err = unpopulate(val, "ContainersList", &b.ContainersList)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &b.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackBackupRequest.
func (c CommitOrRollbackBackupRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", c.AdditionalProperties)
	populate(objectMap, "backupParameters", c.BackupParameters)
	populate(objectMap, "datasource", c.Datasource)
	populate(objectMap, "datasourceAccessToken", c.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", c.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", c.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", c.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", c.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", c.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type CommitOrRollbackRestoreRequest.
func (c CommitOrRollbackRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", c.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", c.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", c.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", c.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", c.ILRRestoreCriteria)
	populate(objectMap, "jobLibraryInitializationParams", c.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", c.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", c.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", c.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", c.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", c.RestoreToRPID)
	populate(objectMap, "restoreType", c.RestoreType)
	populate(objectMap, "sourceDatasource", c.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", c.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", c.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", c.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CommitOrRollbackRestoreRequest.
func (c *CommitOrRollbackRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &c.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &c.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &c.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &c.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				c.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &c.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &c.LoopBackContext)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &c.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &c.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &c.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &c.RestoreToRPID)
				delete(rawMsg, key)
		case "restoreType":
				err = unpopulate(val, "RestoreType", &c.RestoreType)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &c.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &c.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &c.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &c.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Datasource.
func (d Datasource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseUri", d.BaseURI)
	populate(objectMap, "datasourceType", d.DatasourceType)
	populate(objectMap, "objectType", d.ObjectType)
	populate(objectMap, "resourceID", d.ResourceID)
	populate(objectMap, "resourceLocation", d.ResourceLocation)
	populate(objectMap, "resourceName", d.ResourceName)
	populate(objectMap, "resourceProperties", d.ResourceProperties)
	populate(objectMap, "resourceType", d.ResourceType)
	populate(objectMap, "resourceUri", d.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Datasource.
func (d *Datasource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
				err = unpopulate(val, "BaseURI", &d.BaseURI)
				delete(rawMsg, key)
		case "datasourceType":
				err = unpopulate(val, "DatasourceType", &d.DatasourceType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &d.ObjectType)
				delete(rawMsg, key)
		case "resourceID":
				err = unpopulate(val, "ResourceID", &d.ResourceID)
				delete(rawMsg, key)
		case "resourceLocation":
				err = unpopulate(val, "ResourceLocation", &d.ResourceLocation)
				delete(rawMsg, key)
		case "resourceName":
				err = unpopulate(val, "ResourceName", &d.ResourceName)
				delete(rawMsg, key)
		case "resourceProperties":
				d.ResourceProperties, err = unmarshalBaseResourcePropertiesClassification(val)
				delete(rawMsg, key)
		case "resourceType":
				err = unpopulate(val, "ResourceType", &d.ResourceType)
				delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, "ResourceURI", &d.ResourceURI)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatasourceSet.
func (d DatasourceSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "baseUri", d.BaseURI)
	populate(objectMap, "datasourceType", d.DatasourceType)
	populate(objectMap, "objectType", d.ObjectType)
	populate(objectMap, "resourceID", d.ResourceID)
	populate(objectMap, "resourceLocation", d.ResourceLocation)
	populate(objectMap, "resourceName", d.ResourceName)
	populate(objectMap, "resourceProperties", d.ResourceProperties)
	populate(objectMap, "resourceType", d.ResourceType)
	populate(objectMap, "resourceUri", d.ResourceURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatasourceSet.
func (d *DatasourceSet) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseUri":
				err = unpopulate(val, "BaseURI", &d.BaseURI)
				delete(rawMsg, key)
		case "datasourceType":
				err = unpopulate(val, "DatasourceType", &d.DatasourceType)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &d.ObjectType)
				delete(rawMsg, key)
		case "resourceID":
				err = unpopulate(val, "ResourceID", &d.ResourceID)
				delete(rawMsg, key)
		case "resourceLocation":
				err = unpopulate(val, "ResourceLocation", &d.ResourceLocation)
				delete(rawMsg, key)
		case "resourceName":
				err = unpopulate(val, "ResourceName", &d.ResourceName)
				delete(rawMsg, key)
		case "resourceProperties":
				d.ResourceProperties, err = unmarshalBaseResourcePropertiesClassification(val)
				delete(rawMsg, key)
		case "resourceType":
				err = unpopulate(val, "ResourceType", &d.ResourceType)
				delete(rawMsg, key)
		case "resourceUri":
				err = unpopulate(val, "ResourceURI", &d.ResourceURI)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemPathBasedRestoreCriteria.
func (i ItemPathBasedRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isPathRelativeToBackupItem", i.IsPathRelativeToBackupItem)
	populate(objectMap, "itemPath", i.ItemPath)
	objectMap["objectType"] = "ItemPathBasedRestoreCriteria"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemPathBasedRestoreCriteria.
func (i *ItemPathBasedRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isPathRelativeToBackupItem":
				err = unpopulate(val, "IsPathRelativeToBackupItem", &i.IsPathRelativeToBackupItem)
				delete(rawMsg, key)
		case "itemPath":
				err = unpopulate(val, "ItemPath", &i.ItemPath)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &i.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesPVRestoreCriteria.
func (k KubernetesPVRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", k.Name)
	objectMap["objectType"] = "KubernetesPVRestoreCriteria"
	populate(objectMap, "storageClassName", k.StorageClassName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesPVRestoreCriteria.
func (k *KubernetesPVRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &k.Name)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &k.ObjectType)
				delete(rawMsg, key)
		case "storageClassName":
				err = unpopulate(val, "StorageClassName", &k.StorageClassName)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type KubernetesStorageClassRestoreCriteria.
func (k KubernetesStorageClassRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = "KubernetesStorageClassRestoreCriteria"
	populate(objectMap, "provisioner", k.Provisioner)
	populate(objectMap, "selectedStorageClassName", k.SelectedStorageClassName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type KubernetesStorageClassRestoreCriteria.
func (k *KubernetesStorageClassRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", k, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &k.ObjectType)
				delete(rawMsg, key)
		case "provisioner":
				err = unpopulate(val, "Provisioner", &k.Provisioner)
				delete(rawMsg, key)
		case "selectedStorageClassName":
				err = unpopulate(val, "SelectedStorageClassName", &k.SelectedStorageClassName)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", k, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PolicyParameters.
func (p PolicyParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupDatasourceParametersList", p.BackupDatasourceParametersList)
	populate(objectMap, "dataStoreParametersList", p.DataStoreParametersList)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PolicyParameters.
func (p *PolicyParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupDatasourceParametersList":
				p.BackupDatasourceParametersList, err = unmarshalBackupDatasourceParametersClassificationArray(val)
				delete(rawMsg, key)
		case "dataStoreParametersList":
				p.DataStoreParametersList, err = unmarshalDataStoreParametersClassificationArray(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectionRequestBase.
func (p ProtectionRequestBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", p.AdditionalProperties)
	populate(objectMap, "backupSettings", p.BackupSettings)
	populate(objectMap, "datasource", p.Datasource)
	populate(objectMap, "datasourceAccessToken", p.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", p.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", p.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type RangeBasedItemLevelRestoreCriteria.
func (r RangeBasedItemLevelRestoreCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "maxMatchingValue", r.MaxMatchingValue)
	populate(objectMap, "minMatchingValue", r.MinMatchingValue)
	objectMap["objectType"] = "RangeBasedItemLevelRestoreCriteria"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RangeBasedItemLevelRestoreCriteria.
func (r *RangeBasedItemLevelRestoreCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxMatchingValue":
				err = unpopulate(val, "MaxMatchingValue", &r.MaxMatchingValue)
				delete(rawMsg, key)
		case "minMatchingValue":
				err = unpopulate(val, "MinMatchingValue", &r.MinMatchingValue)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &r.ObjectType)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreRequest.
func (r RestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", r.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", r.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", r.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", r.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", r.ILRRestoreCriteria)
	populate(objectMap, "jobLibraryInitializationParams", r.JobLibraryInitializationParams)
	populate(objectMap, "loopBackContext", r.LoopBackContext)
	populate(objectMap, "rPCatalogInitializeParams", r.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", r.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", r.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", r.RestoreToRPID)
	populate(objectMap, "restoreType", r.RestoreType)
	populate(objectMap, "sourceDatasource", r.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", r.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", r.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", r.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreRequest.
func (r *RestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &r.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &r.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &r.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &r.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				r.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &r.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "loopBackContext":
				err = unpopulate(val, "LoopBackContext", &r.LoopBackContext)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &r.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &r.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &r.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &r.RestoreToRPID)
				delete(rawMsg, key)
		case "restoreType":
				err = unpopulate(val, "RestoreType", &r.RestoreType)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &r.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &r.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &r.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &r.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RestoreRequestBase.
func (r RestoreRequestBase) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", r.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", r.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", r.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", r.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", r.ILRRestoreCriteria)
	populate(objectMap, "jobLibraryInitializationParams", r.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", r.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", r.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", r.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", r.RestoreToRPID)
	populate(objectMap, "restoreType", r.RestoreType)
	populate(objectMap, "sourceDatasource", r.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", r.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", r.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", r.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RestoreRequestBase.
func (r *RestoreRequestBase) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &r.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &r.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &r.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &r.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				r.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &r.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &r.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &r.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &r.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &r.RestoreToRPID)
				delete(rawMsg, key)
		case "restoreType":
				err = unpopulate(val, "RestoreType", &r.RestoreType)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &r.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &r.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &r.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &r.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleBasedBackupCriteria.
func (s ScheduleBasedBackupCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "absoluteCriteria", s.AbsoluteCriteria)
	populate(objectMap, "daysOfMonth", s.DaysOfMonth)
	populate(objectMap, "daysOfTheWeek", s.DaysOfTheWeek)
	populate(objectMap, "monthsOfYear", s.MonthsOfYear)
	objectMap["objectType"] = "ScheduleBasedBackupCriteria"
	aux := make([]*timeRFC3339, len(s.ScheduleTimes), len(s.ScheduleTimes))
	for i := 0; i < len(s.ScheduleTimes); i++ {
		aux[i] = (*timeRFC3339)(s.ScheduleTimes[i])
	}
	populate(objectMap, "scheduleTimes", aux)
	populate(objectMap, "weeksOfTheMonth", s.WeeksOfTheMonth)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleBasedBackupCriteria.
func (s *ScheduleBasedBackupCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "absoluteCriteria":
				err = unpopulate(val, "AbsoluteCriteria", &s.AbsoluteCriteria)
				delete(rawMsg, key)
		case "daysOfMonth":
				err = unpopulate(val, "DaysOfMonth", &s.DaysOfMonth)
				delete(rawMsg, key)
		case "daysOfTheWeek":
				err = unpopulate(val, "DaysOfTheWeek", &s.DaysOfTheWeek)
				delete(rawMsg, key)
		case "monthsOfYear":
				err = unpopulate(val, "MonthsOfYear", &s.MonthsOfYear)
				delete(rawMsg, key)
		case "objectType":
				err = unpopulate(val, "ObjectType", &s.ObjectType)
				delete(rawMsg, key)
		case "scheduleTimes":
			var aux []*timeRFC3339
			err = unpopulate(val, "ScheduleTimes", &aux)
			for _, au := range aux {
				s.ScheduleTimes = append(s.ScheduleTimes, (*time.Time)(au))
			}
				delete(rawMsg, key)
		case "weeksOfTheMonth":
				err = unpopulate(val, "WeeksOfTheMonth", &s.WeeksOfTheMonth)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleBasedTriggerContext.
func (s ScheduleBasedTriggerContext) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["objectType"] = "ScheduleBasedTriggerContext"
	populate(objectMap, "schedule", s.Schedule)
	populate(objectMap, "taggingCriteria", s.TaggingCriteria)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleBasedTriggerContext.
func (s *ScheduleBasedTriggerContext) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "objectType":
				err = unpopulate(val, "ObjectType", &s.ObjectType)
				delete(rawMsg, key)
		case "schedule":
				err = unpopulate(val, "Schedule", &s.Schedule)
				delete(rawMsg, key)
		case "taggingCriteria":
				err = unpopulate(val, "TaggingCriteria", &s.TaggingCriteria)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StartProtectionRequest.
func (s StartProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", s.AdditionalProperties)
	populate(objectMap, "backupSettings", s.BackupSettings)
	populate(objectMap, "datasource", s.Datasource)
	populate(objectMap, "datasourceAccessToken", s.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", s.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", s.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StopProtectionRequest.
func (s StopProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", s.AdditionalProperties)
	populate(objectMap, "backupSettings", s.BackupSettings)
	populate(objectMap, "datasource", s.Datasource)
	populate(objectMap, "datasourceAccessToken", s.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", s.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", s.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type TaggingCriteria.
func (t TaggingCriteria) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "criteria", t.Criteria)
	populate(objectMap, "isDefault", t.IsDefault)
	populate(objectMap, "tagInfo", t.TagInfo)
	populate(objectMap, "taggingPriority", t.TaggingPriority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TaggingCriteria.
func (t *TaggingCriteria) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "criteria":
				t.Criteria, err = unmarshalBackupCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "isDefault":
				err = unpopulate(val, "IsDefault", &t.IsDefault)
				delete(rawMsg, key)
		case "tagInfo":
				err = unpopulate(val, "TagInfo", &t.TagInfo)
				delete(rawMsg, key)
		case "taggingPriority":
				err = unpopulate(val, "TaggingPriority", &t.TaggingPriority)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpdateProtectionRequest.
func (u UpdateProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", u.AdditionalProperties)
	populate(objectMap, "backupSettings", u.BackupSettings)
	populate(objectMap, "datasource", u.Datasource)
	populate(objectMap, "datasourceAccessToken", u.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", u.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", u.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForBackupRequest.
func (v ValidateForBackupRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "backupParameters", v.BackupParameters)
	populate(objectMap, "datasource", v.Datasource)
	populate(objectMap, "datasourceAccessToken", v.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", v.DatasourceSet)
	populate(objectMap, "datastoreInitializeParams", v.DatastoreInitializeParams)
	populate(objectMap, "jobLibraryInitializationParams", v.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", v.RPCatalogInitializeParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForProtectionRequest.
func (v ValidateForProtectionRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "backupSettings", v.BackupSettings)
	populate(objectMap, "datasource", v.Datasource)
	populate(objectMap, "datasourceAccessToken", v.DatasourceAccessToken)
	populate(objectMap, "datasourceSet", v.DatasourceSet)
	populate(objectMap, "jobLibraryInitializationParams", v.JobLibraryInitializationParams)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ValidateForRestoreRequest.
func (v ValidateForRestoreRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", v.AdditionalProperties)
	populate(objectMap, "datasourceAccessToken", v.DatasourceAccessToken)
	populate(objectMap, "datastoreInitializeParams", v.DatastoreInitializeParams)
	populate(objectMap, "forceOverwrite", v.ForceOverwrite)
	populate(objectMap, "iLRRestoreCriteria", v.ILRRestoreCriteria)
	populate(objectMap, "isValidateOnlyOperation", v.IsValidateOnlyOperation)
	populate(objectMap, "jobLibraryInitializationParams", v.JobLibraryInitializationParams)
	populate(objectMap, "rPCatalogInitializeParams", v.RPCatalogInitializeParams)
	populate(objectMap, "restoreAsFilesTargetDetails", v.RestoreAsFilesTargetDetails)
	populate(objectMap, "restoreToPointInTime", v.RestoreToPointInTime)
	populate(objectMap, "restoreToRPId", v.RestoreToRPID)
	populate(objectMap, "restoreType", v.RestoreType)
	populate(objectMap, "sourceDatasource", v.SourceDatasource)
	populate(objectMap, "sourceDatasourceSet", v.SourceDatasourceSet)
	populate(objectMap, "targetDatasource", v.TargetDatasource)
	populate(objectMap, "targetDatasourceSet", v.TargetDatasourceSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateForRestoreRequest.
func (v *ValidateForRestoreRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalProperties":
				err = unpopulate(val, "AdditionalProperties", &v.AdditionalProperties)
				delete(rawMsg, key)
		case "datasourceAccessToken":
				err = unpopulate(val, "DatasourceAccessToken", &v.DatasourceAccessToken)
				delete(rawMsg, key)
		case "datastoreInitializeParams":
				err = unpopulate(val, "DatastoreInitializeParams", &v.DatastoreInitializeParams)
				delete(rawMsg, key)
		case "forceOverwrite":
				err = unpopulate(val, "ForceOverwrite", &v.ForceOverwrite)
				delete(rawMsg, key)
		case "iLRRestoreCriteria":
				v.ILRRestoreCriteria, err = unmarshalItemLevelRestoreCriteriaClassificationArray(val)
				delete(rawMsg, key)
		case "isValidateOnlyOperation":
				err = unpopulate(val, "IsValidateOnlyOperation", &v.IsValidateOnlyOperation)
				delete(rawMsg, key)
		case "jobLibraryInitializationParams":
				err = unpopulate(val, "JobLibraryInitializationParams", &v.JobLibraryInitializationParams)
				delete(rawMsg, key)
		case "rPCatalogInitializeParams":
				err = unpopulate(val, "RPCatalogInitializeParams", &v.RPCatalogInitializeParams)
				delete(rawMsg, key)
		case "restoreAsFilesTargetDetails":
				err = unpopulate(val, "RestoreAsFilesTargetDetails", &v.RestoreAsFilesTargetDetails)
				delete(rawMsg, key)
		case "restoreToPointInTime":
				err = unpopulate(val, "RestoreToPointInTime", &v.RestoreToPointInTime)
				delete(rawMsg, key)
		case "restoreToRPId":
				err = unpopulate(val, "RestoreToRPID", &v.RestoreToRPID)
				delete(rawMsg, key)
		case "restoreType":
				err = unpopulate(val, "RestoreType", &v.RestoreType)
				delete(rawMsg, key)
		case "sourceDatasource":
				err = unpopulate(val, "SourceDatasource", &v.SourceDatasource)
				delete(rawMsg, key)
		case "sourceDatasourceSet":
				err = unpopulate(val, "SourceDatasourceSet", &v.SourceDatasourceSet)
				delete(rawMsg, key)
		case "targetDatasource":
				err = unpopulate(val, "TargetDatasource", &v.TargetDatasource)
				delete(rawMsg, key)
		case "targetDatasourceSet":
				err = unpopulate(val, "TargetDatasourceSet", &v.TargetDatasourceSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v interface{}) error {
	if data == nil {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

